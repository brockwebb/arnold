#!/usr/bin/env python3
"""
HRR QC Review Tool
Keyboard-driven workflow for reviewing HRR interval quality decisions.

Key design:
- Speed is paramount: Enter = accept default (confirm)
- Session-level "all good" to skip sessions where algo is correct
- Reason codes are one-key selections, not typing
- Visual context without plot overhead (use separate viewer)
"""

import os
import sys
from datetime import datetime
from typing import Optional, List, Tuple
import psycopg2
from psycopg2.extras import RealDictCursor
import click
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.prompt import Prompt, Confirm
from rich import box

console = Console()

# Database connection
DB_URL = os.environ.get('DATABASE_URL', 'postgresql://localhost:5432/arnold_analytics')

def get_db():
    """Get database connection."""
    return psycopg2.connect(DB_URL, cursor_factory=RealDictCursor)


# =============================================================================
# REASON CODES
# =============================================================================

REJECT_CODES = [
    ('1', 'peak_misplaced', 'Peak not at true maximum'),
    ('2', 'double_peak_undetected', 'Double peak not detected'),
    ('3', 'early_termination', 'Recovery cut too short'),
    ('4', 'late_onset', 'Peak detection started late'),
    ('5', 'no_true_recovery', 'Not a true recovery'),
    ('6', 'signal_artifact', 'Noise/artifact'),
    ('7', 'sub_threshold', 'Below activation threshold'),
    ('o', 'other', 'Other (will prompt for notes)'),
]

OVERRIDE_CODES = [
    ('1', 'false_positive_double', 'False double peak detection'),
    ('2', 'acceptable_r2', 'R² acceptable for analysis'),
    ('3', 'known_context', 'Contextual knowledge (notes required)'),
    ('4', 'peak_shift_fixes', 'Peak shift makes it valid'),
    ('5', 'hiit_expected', 'Expected for HIIT pattern'),
    ('o', 'other', 'Other (will prompt for notes)'),
]


# =============================================================================
# DATA ACCESS
# =============================================================================

def get_sessions_summary(db) -> List[dict]:
    """Get summary of all sessions with intervals."""
    with db.cursor() as cur:
        cur.execute("""
            SELECT 
                ps.id as session_id,
                ps.start_time::date as session_date,
                ps.sport_type,
                COUNT(*) as total,
                COUNT(*) FILTER (WHERE hri.quality_status = 'pass') as passed,
                COUNT(*) FILTER (WHERE hri.quality_status = 'rejected') as rejected,
                COUNT(*) FILTER (WHERE hri.quality_status = 'flagged') as flagged,
                COUNT(*) FILTER (WHERE hri.needs_review = true) as needs_review,
                COUNT(*) FILTER (WHERE hri.human_verified = true) as verified,
                ROUND(AVG(hri.hrr60_abs) FILTER (WHERE hri.quality_status = 'pass'), 1) as avg_hrr60
            FROM polar_sessions ps
            JOIN hr_recovery_intervals hri ON hri.polar_session_id = ps.id
            WHERE hri.excluded IS NOT TRUE
            GROUP BY ps.id, ps.start_time, ps.sport_type
            ORDER BY ps.start_time
        """)
        return cur.fetchall()


def get_session_intervals(db, session_id: int) -> List[dict]:
    """Get all intervals for a session."""
    with db.cursor() as cur:
        cur.execute("""
            SELECT 
                id,
                interval_order,
                quality_status,
                quality_flags,
                auto_reject_reason,
                hrr60_abs,
                tau_fit_r2,
                r2_0_30,
                r2_30_60,
                r2_30_90,
                hr_peak,
                hr_60s,
                duration_seconds,
                start_time,
                human_verified,
                needs_review,
                notes
            FROM hr_recovery_intervals
            WHERE polar_session_id = %s
              AND excluded IS NOT TRUE
            ORDER BY interval_order
        """, (session_id,))
        return cur.fetchall()


def record_judgment(db, interval: dict, human_status: str, 
                   reason_code: Optional[str] = None,
                   notes: Optional[str] = None,
                   peak_shift: Optional[int] = None):
    """Record a QC judgment for an interval."""
    with db.cursor() as cur:
        # Insert judgment record
        cur.execute("""
            INSERT INTO hrr_qc_judgments (
                polar_session_id, interval_order, judgment,
                algo_status, algo_reject_reason, interval_id,
                interval_start_ts, human_status, reason_code, notes,
                peak_shift_sec, judged_at
            ) VALUES (
                %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW()
            )
            ON CONFLICT (polar_session_id, interval_order) 
            DO UPDATE SET
                judgment = EXCLUDED.judgment,
                human_status = EXCLUDED.human_status,
                reason_code = EXCLUDED.reason_code,
                notes = EXCLUDED.notes,
                peak_shift_sec = EXCLUDED.peak_shift_sec,
                judged_at = NOW()
        """, (
            interval['polar_session_id'] if 'polar_session_id' in interval else None,
            interval['interval_order'],
            human_status,  # legacy field
            interval['quality_status'],
            interval.get('auto_reject_reason'),
            interval['id'],
            interval['start_time'],
            human_status,
            reason_code,
            notes,
            peak_shift
        ))
        
        # Update the interval's verification status
        cur.execute("""
            UPDATE hr_recovery_intervals
            SET human_verified = true,
                verified_at = NOW(),
                verified_status = %s,
                verification_notes = %s,
                needs_review = false
            WHERE id = %s
        """, (human_status, notes, interval['id']))
        
        db.commit()


def batch_confirm_session(db, session_id: int, intervals: List[dict]):
    """Batch confirm all passed intervals in a session."""
    confirmed = 0
    for interval in intervals:
        # Confirm all intervals, not just passes
        if True:  # was: interval['quality_status'] == 'pass'
            interval['polar_session_id'] = session_id
            record_judgment(db, interval, 'confirm_pass')
            confirmed += 1
    
    # Record session-level review
    with db.cursor() as cur:
        cur.execute("""
            INSERT INTO hrr_session_reviews (
                polar_session_id, review_action, intervals_confirmed,
                intervals_rejected, intervals_skipped, reviewed_at
            ) VALUES (%s, 'batch_confirm_passed', %s, 0, %s, NOW())
        """, (session_id, confirmed, len(intervals) - confirmed))
        db.commit()
    
    return confirmed


# =============================================================================
# UI COMPONENTS
# =============================================================================

def show_session_list(sessions: List[dict]):
    """Display session summary table."""
    table = Table(title="Sessions Overview", box=box.ROUNDED)
    table.add_column("#", style="dim")
    table.add_column("Date")
    table.add_column("Sport")
    table.add_column("Pass", style="green")
    table.add_column("Reject", style="red")
    table.add_column("Flag", style="yellow")
    table.add_column("Review", style="cyan")
    table.add_column("Verified", style="blue")
    table.add_column("HRR60")
    
    for i, s in enumerate(sessions, 1):
        review_indicator = "⚠" if s['needs_review'] > 0 else ""
        table.add_row(
            str(s['session_id']),
            str(s['session_date']),
            s['sport_type'] or '-',
            str(s['passed']),
            str(s['rejected']),
            str(s['flagged']),
            f"{s['needs_review']}{review_indicator}",
            str(s['verified']),
            str(s['avg_hrr60'] or '-')
        )
    
    console.print(table)


def show_interval(interval: dict, index: int, total: int):
    """Display single interval for review."""
    status_colors = {
        'pass': 'green',
        'rejected': 'red',
        'flagged': 'yellow'
    }
    color = status_colors.get(interval['quality_status'], 'white')
    
    # Build info panel
    info = f"""[{color}]{interval['quality_status'].upper()}[/{color}] | Interval #{interval['interval_order']} ({index}/{total})
    
[bold]Key Metrics:[/bold]
  HRR60: {interval['hrr60_abs'] or '-'} bpm
  Peak HR: {interval['hr_peak']} → 60s: {interval['hr_60s'] or '-'}
  τ R²: {float(interval['tau_fit_r2'] or 0):.3f}
  
[bold]Segment R²:[/bold]
  0-30s: {float(interval['r2_0_30'] or 0):.3f}
  30-60s: {float(interval['r2_30_60'] or 0):.3f}
  30-90s: {float(interval['r2_30_90'] or 0):.3f}
  
[bold]Duration:[/bold] {interval['duration_seconds']}s"""

    if interval['quality_flags']:
        flags = ', '.join(interval['quality_flags'])
        info += f"\n[yellow]Flags: {flags}[/yellow]"
    
    if interval['auto_reject_reason']:
        info += f"\n[red]Reject reason: {interval['auto_reject_reason']}[/red]"
    
    if interval['notes']:
        info += f"\n[dim]Notes: {interval['notes']}[/dim]"
    
    verified = "✓ Verified" if interval['human_verified'] else ""
    title = f"Interval Review {verified}"
    
    console.print(Panel(info, title=title, border_style=color))


def show_reason_codes(codes: List[Tuple[str, str, str]], action: str):
    """Display reason code options."""
    console.print(f"\n[bold]{action} - Select reason:[/bold]")
    for key, code, desc in codes:
        console.print(f"  [{key}] {desc}")
    console.print("  [Esc/q] Cancel")


def get_single_key(prompt_text: str) -> str:
    """Get single keypress (cross-platform)."""
    console.print(prompt_text, end='', style="bold cyan")
    try:
        import termios
        import tty
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(fd)
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        console.print()  # newline
        return ch
    except ImportError:
        # Windows fallback
        import msvcrt
        ch = msvcrt.getch().decode('utf-8', errors='ignore')
        console.print()
        return ch


# =============================================================================
# REVIEW WORKFLOWS
# =============================================================================

def review_single_interval(db, interval: dict, session_id: int) -> str:
    """Review a single interval. Returns action taken."""
    interval['polar_session_id'] = session_id
    status = interval['quality_status']
    
    # Show actions based on current status
    if status == 'pass':
        console.print("\n[green]PASSED[/green] → [Enter]=Confirm  [R]=Reject  [S]=Skip  [Q]=Quit session")
    else:
        console.print("\n[red]REJECTED[/red] → [Enter]=Confirm rejection  [O]=Override (accept)  [S]=Skip  [Q]=Quit session")
    
    key = get_single_key("> ")
    
    if key in ('\r', '\n', ''):
        # Default: confirm current status
        if status == 'pass':
            record_judgment(db, interval, 'confirm_pass')
            console.print("[green]✓ Confirmed pass[/green]")
            return 'confirmed'
        else:
            record_judgment(db, interval, 'confirm_rejection')
            console.print("[red]✓ Confirmed rejection[/red]")
            return 'confirmed'
    
    elif key.lower() == 'r' and status == 'pass':
        # Reject a passed interval
        show_reason_codes(REJECT_CODES, "Reject passed interval")
        reason_key = get_single_key("> ")
        
        for k, code, desc in REJECT_CODES:
            if reason_key == k:
                notes = None
                if code == 'other':
                    notes = Prompt.ask("Notes")
                record_judgment(db, interval, 'reject_passed', code, notes)
                console.print(f"[red]✗ Rejected: {desc}[/red]")
                return 'rejected'
        
        console.print("[dim]Cancelled[/dim]")
        return 'skipped'
    
    elif key.lower() == 'o' and status != 'pass':
        # Override a rejection
        show_reason_codes(OVERRIDE_CODES, "Override rejection")
        reason_key = get_single_key("> ")
        
        for k, code, desc in OVERRIDE_CODES:
            if reason_key == k:
                notes = None
                peak_shift = None
                
                if code == 'other' or code == 'known_context':
                    notes = Prompt.ask("Notes")
                
                if code == 'peak_shift_fixes':
                    shift_str = Prompt.ask("Peak shift (seconds, + or -)", default="0")
                    try:
                        peak_shift = int(shift_str)
                    except ValueError:
                        peak_shift = None
                
                record_judgment(db, interval, 'override_accept', code, notes, peak_shift)
                console.print(f"[green]✓ Overridden to accept: {desc}[/green]")
                return 'overridden'
        
        console.print("[dim]Cancelled[/dim]")
        return 'skipped'
    
    elif key.lower() == 's':
        console.print("[dim]Skipped[/dim]")
        return 'skipped'
    
    elif key.lower() == 'q':
        return 'quit'
    
    else:
        console.print("[dim]Unknown key, skipping[/dim]")
        return 'skipped'


def review_session(db, session_id: int, session_info: dict):
    """Review all intervals in a session."""
    intervals = get_session_intervals(db, session_id)
    
    if not intervals:
        console.print("[yellow]No intervals found[/yellow]")
        return
    
    console.clear()
    console.print(f"\n[bold]Session {session_id}: {session_info['session_date']} - {session_info['sport_type'] or 'Unknown'}[/bold]")
    console.print(f"Total: {len(intervals)} intervals | "
                  f"Pass: {session_info['passed']} | "
                  f"Reject: {session_info['rejected']} | "
                  f"Flagged: {session_info['flagged']}")
    
    # Quick session-level options
    console.print("\n[bold cyan]Session Actions:[/bold cyan]")
    console.print("  [A] All Good - batch confirm all passed intervals")
    console.print("  [R] Review individually")
    console.print("  [S] Skip session")
    console.print("  [Q] Quit")
    
    key = get_single_key("\n> ")
    
    if key.lower() == 'a':
        confirmed = batch_confirm_session(db, session_id, intervals)
        console.print(f"[green]✓ Batch confirmed {confirmed} passed intervals[/green]")
        return
    
    elif key.lower() == 's':
        console.print("[dim]Session skipped[/dim]")
        return
    
    elif key.lower() == 'q':
        return 'quit'
    
    elif key.lower() != 'r':
        console.print("[dim]Unknown key[/dim]")
        return
    
    # Individual review
    stats = {'confirmed': 0, 'rejected': 0, 'overridden': 0, 'skipped': 0}
    
    for i, interval in enumerate(intervals, 1):
        if interval['human_verified']:
            continue  # Skip already verified
        
        console.clear()
        show_interval(interval, i, len(intervals))
        
        result = review_single_interval(db, interval, session_id)
        
        if result == 'quit':
            break
        
        if result in stats:
            stats[result] += 1
    
    # Summary
    console.print(f"\n[bold]Session Review Complete:[/bold]")
    console.print(f"  Confirmed: {stats['confirmed']}")
    console.print(f"  Rejected: {stats['rejected']}")
    console.print(f"  Overridden: {stats['overridden']}")
    console.print(f"  Skipped: {stats['skipped']}")


# =============================================================================
# CLI COMMANDS
# =============================================================================

@click.group()
def cli():
    """HRR QC Review Tool - Fast keyboard-driven QC workflow."""
    pass


@cli.command()
@click.option("--unverified", "-u", is_flag=True, help="Only unverified sessions")
@click.option("--needs-review", "-r", is_flag=True, help="Only sessions needing review")
def sessions(unverified: bool, needs_review: bool):
    """List all sessions with interval counts."""
    with get_db() as db:
        all_sessions = get_sessions_summary(db)
        show_session_list(all_sessions)


@cli.command()
@click.option('--session', '-s', type=int, help='Specific session ID to review')
@click.option('--unverified', '-u', is_flag=True, help='Only show unverified sessions')
@click.option('--needs-review', '-r', is_flag=True, help='Only show sessions needing review')
def review(session: Optional[int], unverified: bool, needs_review: bool):
    """Interactive review of HRR intervals."""
    with get_db() as db:
        all_sessions = get_sessions_summary(db)
        
        # Filter sessions
        if needs_review:
            all_sessions = [s for s in all_sessions if s['needs_review'] > 0]
        if unverified:
            all_sessions = [s for s in all_sessions if s['verified'] < s['total']]
        
        if session:
            # Review specific session
            target = next((s for s in all_sessions if s['session_id'] == session), None)
            if not target:
                console.print(f"[red]Session {session} not found[/red]")
                return
            result = review_session(db, session, target)
            if result == 'quit':
                return
        else:
            # Show session picker
            show_session_list(all_sessions)
            console.print("\nEnter session number to review, 'q' to quit:")
            
            while True:
                choice = Prompt.ask(">")
                
                if choice.lower() == 'q':
                    break
                
                try:
                    idx = int(choice) - 1
                    if 0 <= idx < len(all_sessions):
                        target = all_sessions[idx]
                        result = review_session(db, target['session_id'], target)
                        if result == 'quit':
                            break
                        # Refresh and show list again
                        all_sessions = get_sessions_summary(db)
                        if needs_review:
                            all_sessions = [s for s in all_sessions if s['needs_review'] > 0]
                        if unverified:
                            all_sessions = [s for s in all_sessions if s['verified'] < s['total']]
                        show_session_list(all_sessions)
                        console.print("\nEnter session number to review, 'q' to quit:")
                    else:
                        console.print("[red]Invalid session number[/red]")
                except ValueError:
                    console.print("[red]Enter a number[/red]")


@cli.command()
@click.argument('session_ids', nargs=-1, type=int)
def batch_confirm(session_ids: Tuple[int]):
    """Batch confirm all passed intervals in specified sessions."""
    if not session_ids:
        console.print("[red]Provide session IDs[/red]")
        return
    
    with get_db() as db:
        for session_id in session_ids:
            intervals = get_session_intervals(db, session_id)
            if intervals:
                confirmed = batch_confirm_session(db, session_id, intervals)
                console.print(f"Session {session_id}: confirmed {confirmed} intervals")
            else:
                console.print(f"Session {session_id}: no intervals found")


@cli.command()
def stats():
    """Show overall QC statistics."""
    with get_db() as db:
        with db.cursor() as cur:
            cur.execute("""
                SELECT
                    COUNT(*) as total,
                    COUNT(*) FILTER (WHERE quality_status = 'pass') as algo_pass,
                    COUNT(*) FILTER (WHERE quality_status = 'rejected') as algo_reject,
                    COUNT(*) FILTER (WHERE quality_status = 'flagged') as algo_flagged,
                    COUNT(*) FILTER (WHERE human_verified = true) as verified,
                    COUNT(*) FILTER (WHERE needs_review = true) as needs_review
                FROM hr_recovery_intervals
                WHERE excluded IS NOT TRUE
            """)
            stats = cur.fetchone()
            
            cur.execute("""
                SELECT human_status, COUNT(*) as count
                FROM hrr_qc_judgments
                WHERE human_status IS NOT NULL
                GROUP BY human_status
                ORDER BY count DESC
            """)
            judgments = cur.fetchall()
    
    console.print("\n[bold]HRR QC Statistics[/bold]")
    console.print(f"Total intervals: {stats['total']}")
    console.print(f"  Algorithm pass: {stats['algo_pass']}")
    console.print(f"  Algorithm reject: {stats['algo_reject']}")
    console.print(f"  Algorithm flagged: {stats['algo_flagged']}")
    console.print(f"\nHuman verified: {stats['verified']} ({100*stats['verified']/stats['total']:.1f}%)")
    console.print(f"Needs review: {stats['needs_review']}")
    
    if judgments:
        console.print("\n[bold]Judgment Distribution:[/bold]")
        for j in judgments:
            console.print(f"  {j['human_status']}: {j['count']}")




@cli.command()
@click.argument('session_id', type=int)
@click.option('--no-show', is_flag=True, help='Save only, do not display')
def viz(session_id: int, no_show: bool):
    """Show HRR visualization for a session."""
    import subprocess
    cmd = ['python', 'scripts/hrr_qc_viz.py', '--session-id', str(session_id)]
    if no_show:
        cmd.append('--no-show')
    subprocess.run(cmd)

@cli.command()
@click.argument('session_id', type=int)
@click.option('--no-show', is_flag=True, help='Save only, do not display')
def viz(session_id: int, no_show: bool):
    """Show HRR visualization for a session."""
    import subprocess
    import os
    script_dir = os.path.dirname(os.path.abspath(__file__))
    cmd = ['python', os.path.join(script_dir, 'hrr_qc_viz.py'), '--session-id', str(session_id)]
    if no_show:
        cmd.append('--no-show')
    subprocess.run(cmd)


if __name__ == '__main__':
    cli()
